# 알고리즘 자주 쓰이는 문법
## 인덴트(Indent)

= 공백 4칸  *by PEP 8*

첫 번째 줄에 파라미터가 있다면 파라미터가 시작되는 부분에 보기 좋게 맞추고, 파라미터를 두 번째 줄부터 쓴다면 인덴트 2번을 추가한 후 맞추어 작성한다.

```python
def long_function_name(var_one,
											 var_two, var_three):
    print(var_one)

def long_function_name(
        var_one, var_two,
        var_three):
    print(var_one)
```

## 네이밍 컨벤션(Naming Convention)

변수명, 함수명 - 스네이크 케이스 (시작 문자를 소문자로 하며, 각 단어를 언더라인(_)으로 구분)

cf. 카멜 케이스 - camelCase , 스네이크 케이스 - snake_case 

*파이썬 코딩 시에는 스네이크 표기법 코딩을 기본으로 하며, 이는 파이썬의 PEP 8 및 철학에 따라 스네이크 코딩을 지향한다고 얘기할 수 있어야 한다. 

## 타입 힌트(Type Hint)

파이썬은 대표적인 동적 타이핑 언어임에도, 타입을 지정할 수 있는 타입 힌트가 PEP 484 문서에 추가됐다. 즉, C나 Java와 같이 타입을 지정하지 않아도 저절로 변수에 들어간 내용에 따라 타입이 결정되는 것이다. 

```python
a: str = "1"
b: int = 1

def fn(a: int) -> bool:
```

위 코드와 같이 파이썬에서도 함수의 파라미터, 리턴형과 변수의 자료형을 명시할 수 있는 문법이 추가되어 오류 발생을 줄일 수 있게 되었다. 

*코딩 테스트에서는 빠른 시간 내에 코드를 완성해야 하며, 주로 간결한 코드이므로 굳이 타입을 지정하지 않아도 되지만, 코드 리뷰나 이후 정리하는 과정에서 타입을 모두 지정하여 보기 좋게 제출한다면 훨씬 좋을 점수를 받을 수 있다!

### mypy package

mypy 패키지를 설치하면 타입 힌트가 잘못 지정된 코드에 한해서 Incompatible return value type 오류를 발생시킨다.

## 리스트 컴프리헨션(List Comprehension)

1. 함수형 기능 - map, filter 등
2. 람다 표현식
    
    ```python
    list(map(lambda x: x+10, [1,2,3]))
    ```
    

ex. 홀수인 경우 2를 곱해 출력하는 리스트 컴프리헨션 예시

```python
>>> for n in range(1, 10+1):
    if n%2==1:
        a.append(n*2)
        
>>> a
[2, 6, 10, 14, 18]

>>> [n*2 for n in range(1, 10+1) if n % 2 == 1]
```

위 여러 줄에 걸쳐 작성한 반복문과 조건문을 아래 한 줄로 간결하게 작성할 수 있다. 

이는 리스트 뿐만 아니라 딕셔너리에서도 사용 가능하다. 

*리스트/딕셔너리 컴프리헨션은 간결하게 작성할 수 있으며 가독성이 좋은 편이지만, 너무 무리하게 복잡하게 작성하는 경우에는 가독성을 떨어뜨릴 수 있어 적절히 사용하는 것이 중요하다. 따라서 표현식은 2개를 넘지 않는 것이 좋다.

## 제너레이터

루프의 반복(iteration) 동작을 제어할 수 있는 루틴 형태

방대한 양의 메모리를 보관하고자 할 때 제너레이터를 이용하는데, 단순히 제너레이터만 생성해두고 필요할 때 언제든 숫자를 만들어낼 수 있다. yield 구문과 함께 사용되어 제너레이터가 여기까지 실행 중이던 값을 내보낸다는 의미로, 함수 리턴과 달리 함수의 종료 없이 맨 끝에 도달할 때까지 계속 실행된다. 

제너레이터로 생성할 수 있는 값은 다양한 타입으로 지정할 수도 있다. yield 구문으로 생성해낸 여러 개의 값들은 next()로 가져올 수 있다.

## range

range()는 제너레이터 방식을 활용하는 대표적인 함수로, range 클래스를 리턴하며 for문과 함께 사용했을 때 내부적으로 제너레이터의 next()를 호출하듯이 다음 숫자를 생성해나간다. 

```python
>>> a = [n for n in range(1000000)]
>>> b = range(1000000)
```

위 두 줄 코드는 서로 같은 값을 담고 있으나, 차지하는 메모리 점유율과 조건이 명확히 다르다. a의 경우 이미 생성된 값이 들어있는 리스트의 형태이고, b는 제너레이터 클래스가 담겨있어 값을 생성해야 한다는 조건만을 가지고 있다. 

그러나, b도 a와 마찬가지로 인덱스를 이용한 접근이 가능하고, 리스트의 길이도 셀 수 있다. 이것이 바로 제너레이터가 가지는 효율성이자 큰 특징이다. 

## enumerate

여러 가지 자료형 (리스트, 튜플, 집합 등)을 인덱스를 포함한 enumerate 객체로 리턴하는 함수이다. list()로 결과를 추출하면 인덱스를 자동 부여해주기 때문에 아래와 같이 한 번에 인덱스와 값을 깔끔하게 처리할 수 있다.

```python
>>> a = ['a1', 'a2', 'a3']
>>> a
['a1', 'a2', 'a3']

>>> list(enumerate(a))
[(0, 'a1'), (1, 'a2'), (2, 'a3')]

>>> for i, v in enumerate(a):
>>>    print(i, v)
    
0 a1
1 a2
2 a3
```

## // 나눗셈 연산자

파이썬 3 이후 버전에서의 // 연산자는 정수형을 나눗셈할 때 동일한 **정수형**을 결과로 리턴하면서 내림 연산자의 역할을 한다. 즉, **몫을 구하는 연산자**이다. 

*cf. 나머지를 구하는 연산자는 ‘%’이다.* 

*몫과 나머지를 동시에 구하려면 divmod() 함수를 사용하여 두 값을 (몫, 나머지)의 형태로 구할 수 있다. 

## print

print()는 코딩 테스트 시에 디버깅을 위해 사용되기도 한다. (BUT 실무에서는 print()를 활용한 디버깅 방법을 추천하지 X) 

### print() 함수를 유용하게 활용할 수 있는 방법

1. 콤마(,)로 구분하기
    
    구분자를 따로 지정하지 않고 두 개 이상의 값을 콤마로 구분해주면 디폴트로 띄어쓰기로 구분된다.   ex) `print(”AI”, “A2”)`
    
2. sep 파라미터로 구분자 지정하기
3. end 파라미터를 공백으로 처리하여 print()의 디폴트인 줄바꿈 제한하기
4. 리스트 출력 시 → join()으로 묶어서 처리하기
    
    ex) `print(' '.join(a))` 으로 처리하면 첫 번째 파라미터로 지정한 구분자로 각 원소가 구분되어 출력된다. 
    
5. *f-string(format string literal)* : 템플릿을 사용하듯 인라인으로 삽입이 가능하다.
    
    ex) `print(f’{idx+1}: {fruit}’)` 기존의 %를 사용하거나 .format을 부여하는 방식보다 훨씬 간결하고 직관적이며 속도가 빠르다. 
    
    *파이썬 3.6 이상의 버전에서만 지원
    

## pass

*pass* = Null Operation : 아무것도 하지 않는 기능

pass를 지정하면 인덴트 오류와 같이 불필요한 오류를 방지할 수 있다. 

## locals

locals() 는 로컬 심볼 테이블 딕셔너리를 가져오는 메소드로, 업데이트가 가능하다. 즉, 로컬에 선언된 모든 변수를 조회할 수 있어 디버깅에 많은 도움이 된다. 

로컬 스코프에 제한을 걸어 정의된 모든 변수를 출력하는 등 정보를 조회할 수 있으므로, 클래스의 특정 메소드 내부에서나 함수 내부의 로컬 정보를 조회하여 잘못 선언한 부분이 없는지 확인하는 용도로 활용할 수 있다. 

*이는 리트코드 문제 풀이 중에도 코드 내부에 출력해 활용할 수 있다.


---
# 파이썬 코딩 스타일
## 변수명과 주석

<aside>
💡 **스네이크 케이스를 지향하며, 주석을 상세히 달자**

</aside>

변수명과 함수명에 각각의 의미를 부여해 작명하고, 이에 대한 설명을 간략히 주석으로 다는 태도는 매우 중요하다. 

*이 책에서는 주석 대신 코드 스니펫으로 코드에 대한 부가 설명을 덧붙였지만, 공부할 때는 주석을 달며 설명을 정리하는 방식으로 학습하자

## 리스트 컴프리헨션

파이썬의 매우 강력한 기능 중 하나인 리스트 컴프리헨션은 특유의 문법과 의미를 축약함으로써 간결한 코드 작성이라는 장점과 동시에 가독성이 떨어진다는 단점도 함께 따른다. 

이를 극복하기 위해서는 **역할별로 줄 구분**을 하는 방식이 있다.

```python
strls = [
		str1[i:i+2].lower() for i in range(len(str1)-1)
		if re.findall('[a-z]{2}', str1[i:i+2].lower())
]
```

- 굳이 짧은 줄 수를 고집할 필요 없다.
- 대체로 표현식이 2개를 넘지 않아야 한다.

## [참고] 구글 파이썬 스타일 가이드

1. 함수의 기본 값으로 가변 객체를 사용하지 않아야 한다. 
    
    ⇒ 기본 값으로 [], {} 의 사용을 지양해야 한다. 
    
    ```python
    No:    def foo(a, b=[]):
    
    No:    def foo(a, b=: Mapping = {}):
    ```
    
    대신 불변 객체를 사용하여 None을 명시적으로 할당하는 것도 좋은 방법이다.
    
    ```python
    Yes:   def foo(a, b=None):
    					if b is None:
    							b = []
    Yes:   def foo(a, b:Optional[Sequence] = None):
    					if b is None:
    							b = []
    ```