# 두 수의 합

[Two Sum - LeetCode](https://leetcode.com/problems/two-sum/)

## Problem

정수 배열에서 두 수를 뽑아 합이 target인 값을 만들 수 있는 두 숫자의 인덱스를 찾는 문제

### ISSUE

- 이중 for문을 돌며 두 수의 합을 일일이 target과 비교하고 결과 배열에 저장 → break로 바로 반복문 탈출

### 코드

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
        result = []
        for i in range(0, len(nums)):
            for j in range(i+1, len(nums)):
                if (nums[i] + nums[j] == target):
                    result.append(i)
                    result.append(j)
                    break

        return result
```

- 파이썬에서는 [ ] 로 한 번에 리스트 자료형을 표현할 수 있기 때문에 따로 append()할 필요 없이 바로 ******************[nums[i], nums[j]]******************로 리턴해주면 된다.

## Solution

### 1. 브루트 포스로 계산

> *브루트 포스(Brute-Force)* 란?
배열을 2번 반복하면서 모든 조합을 더해서 일일이 확인해보는 무차별 대입 방식
> 

이중 for문을 돌며 두 합이 target일 때 반환한다.

### 2. in을 이용한 탐색

모든 조합을 비교할 필요 없이 for문을 돌며 target에서 자기 자신을 뺀 수가 배열 안에 존재하는지를 탐색한다. 

- 전체 시간복잡도는 1번 브루트 포스 풀이와 O(n^2)으로 같지만, in 연산을 사용하는 것이 훨씬 더 가볍고 빠르다.

### 3. 첫 번째 수를 뺀 결과 키 조회

딕셔너리를 사용하여 숫자를 키로, 인덱스를 값으로 저장한 후 키를 조회하는 방식이다. 이렇게 하면 target에서 for문을 도는 수를 뺀 후, 딕셔너리에서 두 번째 숫자를 키로 하는 값을 바로 조회하면 된다. 

- 첫 번째 수 : num, 두 번째 수 : target-num
- 딕셔너리에서의 조회는 O(1)에 가능하므로, 훨씬 빠른 속도로 수행할 수 있는 방법이다.

### 4. 조회 구조 개선

위 방법에서 두 개의 for문을 하나로 통합한 방법이다. 인덱스에 대한 조건식을 따로 해주지 않는 대신 `nums_map[num] = i` 로 값을 갱신해주면 똑같이 수행될 수 있다.

### 5. 투 포인터 이용

왼쪽과 오른쪽 양쪽에서 포인터가 순회하며 해당 포인터들의 값에 대한 합이 target보다 크면 오른쪽 포인터가 왼쪽으로 움직이고, 작으면 왼쪽 포인터가 오른쪽으로 움직이도록 한다.  **단 배열이 정렬된 상태라는 가정이 있다.* 

🚨 주의 - 위 문제처럼 **배열의 인덱스를 기억하고 활용해야 하는 문제**에서는 정렬을 지양한다. 순서를 섞어버리면 알고리즘이 더욱 복잡해질 수 있으므로 주의해서 사용하자!

---

# 빗물 트래핑

[Trapping Rain Water - LeetCode](https://leetcode.com/problems/trapping-rain-water/)

## Problem

높이를 입력 받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하는 문제

### ISSUE

- 높은 막대를 기준으로 인접한 막대의 높이가 더 낮은 만큼 빗물이 쌓이게 된다.
- 투 포인터를 이용하면 가장 높이가 높은 데에서 만났을 때 탐색을 종료하게 된다.

## Solution

### 1. 투 포인터를 최대로 이동

높이와 너비 모든 공간을 차례로 살피는 방법보다 투 포인터를 이용해 가장 높은 높이의 좌우 기둥을 찾아야 한다. 좌우 어느 쪽이든 항상 낮은 쪽이 높은 쪽을 향해서 포인터가 가운데로 점점 이동하므로 오른쪽이 클 때는 왼쪽이 이동(left += 1), 왼쪽이 클 떄는 오른쪽이 이동(right -= 1)하도록 한다. 

그렇다면 최종적으로 두 포인터는 최대 지점에서 만나게 될 것이다. 

### 2. 스택 쌓기

왼쪽부터 스택에 쌓아 나가면서 현재 높이가 이전 높이보다 높은 경우에, 즉 꺾이는 부분인 ‘변곡점’을 기준으로 격차만큼 물 높이(volume)를 채우는 방식이다. 

이전 높이는 들쑥날쑥 하므로 변곡점을 만날 때마다 스택에서 꺼내어 이전과의 차이만큼 더해나가면 된다. 

---

# 세 수의 합

[3Sum - LeetCode](https://leetcode.com/problems/3sum/)

## Problem

배열을 입력받아 합으로 0을 만들 수 있는 3개의 엘리먼트 조합들을 출력하는 문제

### ISSUE

- 앞뒤로 같은 숫자가 있는 경우를 고려하여 일단 sor()로 배열 정렬 후 시작
    - 사실 이는 문제에서 제시된 테스트 케이스의 결과만 봐도 유추할 수 있다.

## Solution

### 1. 브루트 포스로 계산

i, j, k 쓰리 포인터를 이용해서 같은 숫자가 연속된 것을 제외하고 세 개 합이 0이 되는지 검사한다. 예를 들어 i가 0번 위치에 있을 때 j는 i 바로 다음인 1번부터 맨 뒤에서 2번째까지 돌고, j는 i 바로 다음인 2번부터 맨 뒤까지 루프를 돌게 된다. 

하지만 이 방법은 O(n^3)의 시간 복잡도를 가지므로 그리 효율적인 방법은 아니다.

### 2. 투 포인터로 합 계산

1번 방법이 왼쪽에서부터 순서대로 순회했다면, 이는 left, right 2개의 포인터를 두고 양쪽에서 순회하여 2개의 루프로 줄이는 방법이다. 

**⭐ 투 포인터(Two Pointers) 기법**

시작점과 끝점 또는 왼쪽 포인터와 오른쪽 포인터 두 지점을 기준으로 하는 문제 풀이 전략

→ 범위를 좁혀나가는 접근법이므로 주로 정렬된 배열을 대상으로 사용

*[비교] 슬라이딩 윈도우 

고정 사이즈의 윈도우가 이동하면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘
⇒ 교집합의 정보를 공유하고, 차이가 나는 양쪽 끝 원소만 갱신하는 방법

<aside>
🎯 **투 포인터** 기법은 1차원 배열이 있고, 그 배열 내에서 각자 다른 원소를 가리키는 2개의 포인터를 조작하며 원하는 값을 얻고자 할 때 사용하고, **슬라이딩 윈도우**는 배열이나 리스트의 요소의 일정 범위의 값을 비교할 때 사용한다.

</aside>

---

# 배열 파티션 I

## Problem

2*n 개의 배열에서 n개의 쌍을 만든 후 쌍의 최솟값의 합이 최대가 되는 값을 반환하는 문제

### ISSUE

- 페어의 쌍에서 최솟값 전체의 합이 최대가 되려면 배열이 정렬된 상태이면 된다. → sor()로 정렬하고 시작

### 풀이

```python
def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        temp = []
        sum = 0
        for num in nums:
            temp.append(num)

            if len(temp) == 2:
                sum += min(temp)
                temp = []

        return sum
```

## Solution

### 1. 오름차순 풀이

*내림차순으로 풀어도 동일한 결과가 나온다!

합이 최대가 되려면 min() 의 결과가 커야 한다는 것이므로, 배열 정렬 후 인접 요소 페어들에 대한 각각의 최솟값 합이 바로 최대가 된다. 

### 2. 짝수 번째 값 계산

두 개의 페어를 묶어 최솟값을 더해나가는 것인데, 배열의 크기는 2*n으로 고정되어 있으므로 배열 정렬 후 짝수 번째 인덱스에 위치한 값들이 항상 최소일 것이다. 

따라서 반복문을 2씩 점프하며 돌며 더해나가면 된다. 

```python
for i in range(0, len(nums), 2):
    sum += nums[i]
```

*또는 enumerate() 함수를 이용해 for 루프를 도는 방법도 있다.

```python
for i, n in enumerate(nums):
		if i % 2 == 0:
				sum += n
```

- 불필요한 리스트 변수 생략 가능
- 전체 코드를 간략히 줄일 수 있음

🤍 **enumerate() 함수**

파이썬의 for 루프는 기본적으로 `for <원소> in <목록>:` 의 구조로 이루어진다. 

`**<원소>**` - 순회 변수(loop variable)

`**<목록>**` - 리스트, 튜플, 문자열, 반복자(iterator), 제너레이터(generator) 등 순회 가능한 데이터 타입

주로 배열의 인덱스를 다룰 때는 range 함수를 사용하거나 인덱스 변수를 따로 선언한 후에 사용하는데, 이를 파이썬다운 방식으로 바꾸어 ***인덱스와 원소를 동시에 접근***하며 루프를 돌 수 있는 방식이 바로 enumerate() 를 사용하는 것이다. 

enumerate() 는 기본적으로 인덱스와 원소로 이루어진 튜플 형태를 반환하며, 이를 각각 나눠서 사용하고 싶다면 위 코드의 예제와 같이 i, n으로 인자 풀기(unpacking)를 해주면 된다. 

*참고 - [https://www.daleseo.com/python-enumerate/](https://www.daleseo.com/python-enumerate/)

### 3. 파이썬다운 방식

슬라이싱 기법과 파이썬 내장함수 sum(), sorted() 을 활용하여 아래의 단 한 줄로 풀이가 가능해진다. 

`return sum(sorted(nums)[::2])`

---

# 자신을 제외한 배열의 곱

[Product of Array Except Self - LeetCode](https://leetcode.com/problems/product-of-array-except-self/)

## Problem

자신을 제외한 나머지 모든 요소의 곱셈 결과를 출력하는 문제

*주의 - 나눗셈을 하지 않고 O(n)에 풀이하라

### ISSUE

- 이중 for문을 돌며 조건식으로 인덱스가 같지 않을 때만 곱하고 그 결과를 배열에 차례로 넣는다.
- 안쪽 for문을 다 돌았다면 다시 곱셈 결과를 저장하는 변수 1로 초기화

### 풀이

```python
def productExceptSelf(self, nums: List[int]) -> List[int]:
        result = []
        mul = 1
        for j in range(0, len(nums)):
            for i in range(0, len(nums)):
                if i != j:
                    mul *= nums[i]
            result.append(mul)
            mul = 1
        return result
```

## Solution

### 1. 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈

O(n)이 되도록 하려면 배열을 순회하며 자기 자신을 기준으로 왼쪽 곱과 오른쪽 곱을 곱하는 방법 뿐이다. 

변수 i가 오른쪽으로 이동하면서 해당 인덱스의 값을 곱해가고, 오른쪽에서 곱해서 배열에 넣은 후에 오른쪽의 마지막 값부터 차례대로 곱하면 자기 자신을 제외한 값끼리의 곱이 저장된다. 

---

# 주식을 사고팔기 가장 좋은 시점

[Best Time to Buy and Sell Stock - LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

## Problem

한 번의 거래로 낼 수 있는 최대 이익을 산출하는 문제

### ISSUE

- 배열의 최대, 최소를 변수에 저장하고, 최소가 등장한 시점 이후의 최댓값과의 차를 구한다.
    
    → 무조건 최대, 최소만을 구할 것이 아니라 더 앞쪽에 위치한 원소와 뒤쪽에 위치한 원소의 차가 가장 큰 것을 구해야 한다. (최소값이 맨 마지막에 있으면 문제가 됨)
    

### 풀이

```python
def productExceptSelf(self, nums: List[int]) -> int:
        min_num = min(nums)
        max_num = max(nums)

        if nums.index(min_num) < nums.index(max_num):
            return max_num - min_num
        else:
            max_num = 0
            for i in range(nums.index(min_num), len(nums)):
                if max_num < nums[i]:
                    max_num = nums[i]
            return max_num - min_num
```

## Solution

### 1. 브루트 포스로 계산

이중 for문을 돌며 자기자신과 그 다음 값의 차에 대한 최댓값을 max()로 비교하여 더 큰 값으로 저장해나간다. 

*파이썬에서는 if문으로 대소비교 후 최댓값, 최솟값을 갱신해나가는 방식을 max(a,b), min(a,b)으로 한 번에 해결할 수 있다. 

**→ TimeOut ⏰**

### 2. 저점과 현재 값과의 차이 계산

> 값을 그래프로 시각화하여 문제를 파악해보자!
> 

*기술 통계학으로 어려운 문제 풀이에 대한 직관을 맞닥뜨리는 연습해보기

최댓값과 최솟값을 먼저 시스템이 가질 수 없는 값으로 초기화한다.  `profit = -sys.maxsize`  `min_price = sys.maxsize`

이후 최저점과 비교하여 더 작을 경우 최솟값을 갱신하고, 이익 역시 차이가 더 클 경우 최댓값을 갱신한다. 

**🖤 최댓값과 최솟값의 초기값 지정**

최댓값과 최솟값의 초기값을 지정하는 경우는 새로운 값으로 비교 후 갱신하기 위함이다. 따라서 초기화하는 값은 절대 불가능한 값이어야 한다. 

⇒ 최댓값에는 가장 낮은 값으로, 최솟값에는 가장 높은 값으로 초기화해야 한다. 

1. 시스템이 지정할 수 있는 최대, 최소의 값 활용
    
    `max = -sys.maxsize`   `min = sys.maxsize`
    
2. float()를 이용해 무한대 값 지정
    
    `max = float(’-inf’)`  `min = float(’inf’)`
    

*cf. 만약 임의의 값(ex. 999999)으로 지정한다면 ?* 

파이썬의 숫자 자료형은 임의 정밀도를 지원하여 사실상 무한대의 값을 지정할 수 있다. 따라서 아무리 큰 수라 할지라도 얼마든지 더 큰 수가 지정될 수 있으므로 임의의 값을 초깃값으로 지정하는 것은 지양해야 한다. 

<aside>
❗ 대부분의 코딩 테스트 플랫폼에서는 **입력값의 제약조건**이 기술되어 있는 경우가 많으므로, 이 기준에 맞춰서 최댓값과 최솟값을 처리해주면 된다!

</aside>